{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='garden', url='', help='"Garden describes a list of gardens."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Garden', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'operator.gardener.cloud/v1alpha1',
    kind: 'Garden',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"Spec contains the specification of this garden."'),
  spec: {
    '#dns':: d.obj(help='"DNS contains specifications of DNS providers."'),
    dns: {
      '#providers':: d.obj(help='"Providers is a list of DNS providers."'),
      providers: {
        '#secretRef':: d.obj(help='"SecretRef is a reference to a Secret object containing the DNS provider credentials."'),
        secretRef: {
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { secretRef+: { name: name } },
        },
        '#withName':: d.fn(help='"Name is the name of the DNS provider."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withProviderConfig':: d.fn(help='"Config is the provider-specific configuration passed to DNSRecord resources."', args=[d.arg(name='providerConfig', type=d.T.object)]),
        withProviderConfig(providerConfig): { providerConfig: providerConfig },
        '#withProviderConfigMixin':: d.fn(help='"Config is the provider-specific configuration passed to DNSRecord resources."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='providerConfig', type=d.T.object)]),
        withProviderConfigMixin(providerConfig): { providerConfig+: providerConfig },
        '#withType':: d.fn(help='"Type is the type of the DNS provider."', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { type: type },
      },
      '#withProviders':: d.fn(help='"Providers is a list of DNS providers."', args=[d.arg(name='providers', type=d.T.array)]),
      withProviders(providers): { spec+: { dns+: { providers: if std.isArray(v=providers) then providers else [providers] } } },
      '#withProvidersMixin':: d.fn(help='"Providers is a list of DNS providers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='providers', type=d.T.array)]),
      withProvidersMixin(providers): { spec+: { dns+: { providers+: if std.isArray(v=providers) then providers else [providers] } } },
    },
    '#extensions':: d.obj(help='"Extensions contain type and provider information for Garden extensions."'),
    extensions: {
      '#withProviderConfig':: d.fn(help='"ProviderConfig is the configuration passed to extension resource."', args=[d.arg(name='providerConfig', type=d.T.object)]),
      withProviderConfig(providerConfig): { providerConfig: providerConfig },
      '#withProviderConfigMixin':: d.fn(help='"ProviderConfig is the configuration passed to extension resource."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='providerConfig', type=d.T.object)]),
      withProviderConfigMixin(providerConfig): { providerConfig+: providerConfig },
      '#withType':: d.fn(help='"Type is the type of the extension resource."', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { type: type },
    },
    '#runtimeCluster':: d.obj(help='"RuntimeCluster contains configuration for the runtime cluster."'),
    runtimeCluster: {
      '#ingress':: d.obj(help='"Ingress configures Ingress specific settings for the Garden cluster."'),
      ingress: {
        '#controller':: d.obj(help='"Controller configures a Gardener managed Ingress Controller listening on the ingressDomain."'),
        controller: {
          '#withKind':: d.fn(help='"Kind defines which kind of IngressController to use. At the moment only `nginx` is supported"', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { spec+: { runtimeCluster+: { ingress+: { controller+: { kind: kind } } } } },
          '#withProviderConfig':: d.fn(help='"ProviderConfig specifies infrastructure specific configuration for the ingressController"', args=[d.arg(name='providerConfig', type=d.T.object)]),
          withProviderConfig(providerConfig): { spec+: { runtimeCluster+: { ingress+: { controller+: { providerConfig: providerConfig } } } } },
          '#withProviderConfigMixin':: d.fn(help='"ProviderConfig specifies infrastructure specific configuration for the ingressController"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='providerConfig', type=d.T.object)]),
          withProviderConfigMixin(providerConfig): { spec+: { runtimeCluster+: { ingress+: { controller+: { providerConfig+: providerConfig } } } } },
        },
        '#domains':: d.obj(help='"Domains specify the ingress domains of the cluster pointing to the ingress controller endpoint. They will be used\\nto construct ingress URLs for system applications running in runtime cluster."'),
        domains: {
          '#withName':: d.fn(help='"Name is the domain name."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withProvider':: d.fn(help="\"Provider is the name of the DNS provider as declared in the '.spec.dns.providers' section.\\nIt is only optional, if the `.spec.dns` section is not provided at all.\"", args=[d.arg(name='provider', type=d.T.string)]),
          withProvider(provider): { provider: provider },
        },
        '#withDomains':: d.fn(help='"Domains specify the ingress domains of the cluster pointing to the ingress controller endpoint. They will be used\\nto construct ingress URLs for system applications running in runtime cluster."', args=[d.arg(name='domains', type=d.T.array)]),
        withDomains(domains): { spec+: { runtimeCluster+: { ingress+: { domains: if std.isArray(v=domains) then domains else [domains] } } } },
        '#withDomainsMixin':: d.fn(help='"Domains specify the ingress domains of the cluster pointing to the ingress controller endpoint. They will be used\\nto construct ingress URLs for system applications running in runtime cluster."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='domains', type=d.T.array)]),
        withDomainsMixin(domains): { spec+: { runtimeCluster+: { ingress+: { domains+: if std.isArray(v=domains) then domains else [domains] } } } },
      },
      '#networking':: d.obj(help='"Networking defines the networking configuration of the runtime cluster."'),
      networking: {
        '#withBlockCIDRs':: d.fn(help='"BlockCIDRs is a list of network addresses that should be blocked."', args=[d.arg(name='blockCIDRs', type=d.T.array)]),
        withBlockCIDRs(blockCIDRs): { spec+: { runtimeCluster+: { networking+: { blockCIDRs: if std.isArray(v=blockCIDRs) then blockCIDRs else [blockCIDRs] } } } },
        '#withBlockCIDRsMixin':: d.fn(help='"BlockCIDRs is a list of network addresses that should be blocked."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blockCIDRs', type=d.T.array)]),
        withBlockCIDRsMixin(blockCIDRs): { spec+: { runtimeCluster+: { networking+: { blockCIDRs+: if std.isArray(v=blockCIDRs) then blockCIDRs else [blockCIDRs] } } } },
        '#withIpFamilies':: d.fn(help="\"IPFamilies specifies the IP protocol versions to use for the runtime cluster's networking. This field is\\nimmutable.\\nDefaults to [\\\"IPv4\\\"].\"", args=[d.arg(name='ipFamilies', type=d.T.array)]),
        withIpFamilies(ipFamilies): { spec+: { runtimeCluster+: { networking+: { ipFamilies: if std.isArray(v=ipFamilies) then ipFamilies else [ipFamilies] } } } },
        '#withIpFamiliesMixin':: d.fn(help="\"IPFamilies specifies the IP protocol versions to use for the runtime cluster's networking. This field is\\nimmutable.\\nDefaults to [\\\"IPv4\\\"].\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='ipFamilies', type=d.T.array)]),
        withIpFamiliesMixin(ipFamilies): { spec+: { runtimeCluster+: { networking+: { ipFamilies+: if std.isArray(v=ipFamilies) then ipFamilies else [ipFamilies] } } } },
        '#withNodes':: d.fn(help='"Nodes are the CIDRs of the node network. Elements can be appended to this list, but not removed."', args=[d.arg(name='nodes', type=d.T.array)]),
        withNodes(nodes): { spec+: { runtimeCluster+: { networking+: { nodes: if std.isArray(v=nodes) then nodes else [nodes] } } } },
        '#withNodesMixin':: d.fn(help='"Nodes are the CIDRs of the node network. Elements can be appended to this list, but not removed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodes', type=d.T.array)]),
        withNodesMixin(nodes): { spec+: { runtimeCluster+: { networking+: { nodes+: if std.isArray(v=nodes) then nodes else [nodes] } } } },
        '#withPods':: d.fn(help='"Pods are the CIDRs of the pod network. Elements can be appended to this list, but not removed."', args=[d.arg(name='pods', type=d.T.array)]),
        withPods(pods): { spec+: { runtimeCluster+: { networking+: { pods: if std.isArray(v=pods) then pods else [pods] } } } },
        '#withPodsMixin':: d.fn(help='"Pods are the CIDRs of the pod network. Elements can be appended to this list, but not removed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pods', type=d.T.array)]),
        withPodsMixin(pods): { spec+: { runtimeCluster+: { networking+: { pods+: if std.isArray(v=pods) then pods else [pods] } } } },
        '#withServices':: d.fn(help='"Services are the CIDRs of the service network. Elements can be appended to this list, but not removed."', args=[d.arg(name='services', type=d.T.array)]),
        withServices(services): { spec+: { runtimeCluster+: { networking+: { services: if std.isArray(v=services) then services else [services] } } } },
        '#withServicesMixin':: d.fn(help='"Services are the CIDRs of the service network. Elements can be appended to this list, but not removed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.array)]),
        withServicesMixin(services): { spec+: { runtimeCluster+: { networking+: { services+: if std.isArray(v=services) then services else [services] } } } },
      },
      '#provider':: d.obj(help='"Provider defines the provider-specific information for this cluster."'),
      provider: {
        '#withRegion':: d.fn(help='"Region is the region the cluster is deployed to."', args=[d.arg(name='region', type=d.T.string)]),
        withRegion(region): { spec+: { runtimeCluster+: { provider+: { region: region } } } },
        '#withZones':: d.fn(help='"Zones is the list of availability zones the cluster is deployed to."', args=[d.arg(name='zones', type=d.T.array)]),
        withZones(zones): { spec+: { runtimeCluster+: { provider+: { zones: if std.isArray(v=zones) then zones else [zones] } } } },
        '#withZonesMixin':: d.fn(help='"Zones is the list of availability zones the cluster is deployed to."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='zones', type=d.T.array)]),
        withZonesMixin(zones): { spec+: { runtimeCluster+: { provider+: { zones+: if std.isArray(v=zones) then zones else [zones] } } } },
      },
      '#settings':: d.obj(help='"Settings contains certain settings for this cluster."'),
      settings: {
        '#loadBalancerServices':: d.obj(help='"LoadBalancerServices controls certain settings for services of type load balancer that are created in the runtime\\ncluster."'),
        loadBalancerServices: {
          '#withAnnotations':: d.fn(help='"Annotations is a map of annotations that will be injected/merged into every load balancer service object."', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotations(annotations): { spec+: { runtimeCluster+: { settings+: { loadBalancerServices+: { annotations: annotations } } } } },
          '#withAnnotationsMixin':: d.fn(help='"Annotations is a map of annotations that will be injected/merged into every load balancer service object."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotationsMixin(annotations): { spec+: { runtimeCluster+: { settings+: { loadBalancerServices+: { annotations+: annotations } } } } },
        },
        '#topologyAwareRouting':: d.obj(help='"TopologyAwareRouting controls certain settings for topology-aware traffic routing in the cluster.\\nSee https://github.com/gardener/gardener/blob/master/docs/operations/topology_aware_routing.md."'),
        topologyAwareRouting: {
          '#withEnabled':: d.fn(help='"Enabled controls whether certain Services deployed in the cluster should be topology-aware.\\nThese Services are virtual-garden-etcd-main-client, virtual-garden-etcd-events-client and virtual-garden-kube-apiserver.\\nAdditionally, other components that are deployed to the runtime cluster via other means can read this field and\\naccording to its value enable/disable topology-aware routing for their Services."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { runtimeCluster+: { settings+: { topologyAwareRouting+: { enabled: enabled } } } } },
        },
        '#verticalPodAutoscaler':: d.obj(help='"VerticalPodAutoscaler controls certain settings for the vertical pod autoscaler components deployed in the\\ncluster."'),
        verticalPodAutoscaler: {
          '#withEnabled':: d.fn(help='"Enabled controls whether the VPA components shall be deployed into this cluster. It is true by default because\\nthe operator (and Gardener) heavily rely on a VPA being deployed. You should only disable this if your runtime\\ncluster already has another, manually/custom managed VPA deployment. If this is not the case, but you still\\ndisable it, then reconciliation will fail."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { runtimeCluster+: { settings+: { verticalPodAutoscaler+: { enabled: enabled } } } } },
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { runtimeCluster+: { settings+: { verticalPodAutoscaler+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { runtimeCluster+: { settings+: { verticalPodAutoscaler+: { featureGates+: featureGates } } } } },
          '#withMaxAllowed':: d.fn(help='"MaxAllowed specifies the global maximum allowed (maximum amount of resources) that vpa-recommender can recommend for a container.\\nThe VerticalPodAutoscaler-level maximum allowed takes precedence over the global maximum allowed.\\nFor more information, see https://github.com/kubernetes/autoscaler/blob/master/vertical-pod-autoscaler/docs/examples.md#specifying-global-maximum-allowed-resources-to-prevent-pods-from-being-unschedulable.\\n\\nDefaults to nil (no maximum)."', args=[d.arg(name='maxAllowed', type=d.T.object)]),
          withMaxAllowed(maxAllowed): { spec+: { runtimeCluster+: { settings+: { verticalPodAutoscaler+: { maxAllowed: maxAllowed } } } } },
          '#withMaxAllowedMixin':: d.fn(help='"MaxAllowed specifies the global maximum allowed (maximum amount of resources) that vpa-recommender can recommend for a container.\\nThe VerticalPodAutoscaler-level maximum allowed takes precedence over the global maximum allowed.\\nFor more information, see https://github.com/kubernetes/autoscaler/blob/master/vertical-pod-autoscaler/docs/examples.md#specifying-global-maximum-allowed-resources-to-prevent-pods-from-being-unschedulable.\\n\\nDefaults to nil (no maximum)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='maxAllowed', type=d.T.object)]),
          withMaxAllowedMixin(maxAllowed): { spec+: { runtimeCluster+: { settings+: { verticalPodAutoscaler+: { maxAllowed+: maxAllowed } } } } },
        },
      },
      '#volume':: d.obj(help='"Volume contains settings for persistent volumes created in the runtime cluster."'),
      volume: {
        '#withMinimumSize':: d.fn(help='"MinimumSize defines the minimum size that should be used for PVCs in the runtime cluster."', args=[d.arg(name='minimumSize', type=d.T.any)]),
        withMinimumSize(minimumSize): { spec+: { runtimeCluster+: { volume+: { minimumSize: minimumSize } } } },
      },
    },
    '#virtualCluster':: d.obj(help='"VirtualCluster contains configuration for the virtual cluster."'),
    virtualCluster: {
      '#controlPlane':: d.obj(help='"ControlPlane holds information about the general settings for the control plane of the virtual cluster."'),
      controlPlane: {
        '#withHighAvailability':: d.fn(help='"HighAvailability holds the configuration settings for high availability settings."', args=[d.arg(name='highAvailability', type=d.T.object)]),
        withHighAvailability(highAvailability): { spec+: { virtualCluster+: { controlPlane+: { highAvailability: highAvailability } } } },
        '#withHighAvailabilityMixin':: d.fn(help='"HighAvailability holds the configuration settings for high availability settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='highAvailability', type=d.T.object)]),
        withHighAvailabilityMixin(highAvailability): { spec+: { virtualCluster+: { controlPlane+: { highAvailability+: highAvailability } } } },
      },
      '#dns':: d.obj(help='"DNS holds information about DNS settings."'),
      dns: {
        '#domains':: d.obj(help='"Domains are the external domains of the virtual garden cluster.\\nThe first given domain in this list is immutable."'),
        domains: {
          '#withName':: d.fn(help='"Name is the domain name."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withProvider':: d.fn(help="\"Provider is the name of the DNS provider as declared in the '.spec.dns.providers' section.\\nIt is only optional, if the `.spec.dns` section is not provided at all.\"", args=[d.arg(name='provider', type=d.T.string)]),
          withProvider(provider): { provider: provider },
        },
        '#withDomains':: d.fn(help='"Domains are the external domains of the virtual garden cluster.\\nThe first given domain in this list is immutable."', args=[d.arg(name='domains', type=d.T.array)]),
        withDomains(domains): { spec+: { virtualCluster+: { dns+: { domains: if std.isArray(v=domains) then domains else [domains] } } } },
        '#withDomainsMixin':: d.fn(help='"Domains are the external domains of the virtual garden cluster.\\nThe first given domain in this list is immutable."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='domains', type=d.T.array)]),
        withDomainsMixin(domains): { spec+: { virtualCluster+: { dns+: { domains+: if std.isArray(v=domains) then domains else [domains] } } } },
      },
      '#etcd':: d.obj(help='"ETCD contains configuration for the etcds of the virtual garden cluster."'),
      etcd: {
        '#events':: d.obj(help='"Events contains configuration for the events etcd."'),
        events: {
          '#autoscaling':: d.obj(help='"Autoscaling contains auto-scaling configuration options for etcd."'),
          autoscaling: {
            '#withMinAllowed':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowed(minAllowed): { spec+: { virtualCluster+: { etcd+: { events+: { autoscaling+: { minAllowed: minAllowed } } } } } },
            '#withMinAllowedMixin':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowedMixin(minAllowed): { spec+: { virtualCluster+: { etcd+: { events+: { autoscaling+: { minAllowed+: minAllowed } } } } } },
          },
          '#storage':: d.obj(help='"Storage contains storage configuration."'),
          storage: {
            '#withCapacity':: d.fn(help='"Capacity is the storage capacity for the volumes."', args=[d.arg(name='capacity', type=d.T.any)]),
            withCapacity(capacity): { spec+: { virtualCluster+: { etcd+: { events+: { storage+: { capacity: capacity } } } } } },
            '#withClassName':: d.fn(help='"ClassName is the name of a storage class."', args=[d.arg(name='className', type=d.T.string)]),
            withClassName(className): { spec+: { virtualCluster+: { etcd+: { events+: { storage+: { className: className } } } } } },
          },
        },
        '#main':: d.obj(help='"Main contains configuration for the main etcd."'),
        main: {
          '#autoscaling':: d.obj(help='"Autoscaling contains auto-scaling configuration options for etcd."'),
          autoscaling: {
            '#withMinAllowed':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowed(minAllowed): { spec+: { virtualCluster+: { etcd+: { main+: { autoscaling+: { minAllowed: minAllowed } } } } } },
            '#withMinAllowedMixin':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowedMixin(minAllowed): { spec+: { virtualCluster+: { etcd+: { main+: { autoscaling+: { minAllowed+: minAllowed } } } } } },
          },
          '#backup':: d.obj(help='"Backup contains the object store configuration for backups for the virtual garden etcd."'),
          backup: {
            '#secretRef':: d.obj(help='"SecretRef is a reference to a Secret object containing the cloud provider credentials for the object store where\\nbackups should be stored. It should have enough privileges to manipulate the objects as well as buckets."'),
            secretRef: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { secretRef+: { name: name } } } } } } },
            },
            '#withBucketName':: d.fn(help='"BucketName is the name of the backup bucket. If not provided, gardener-operator attempts to manage a new bucket.\\nIn this case, the cloud provider credentials provided in the SecretRef must have enough privileges for creating\\nand deleting buckets."', args=[d.arg(name='bucketName', type=d.T.string)]),
            withBucketName(bucketName): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { bucketName: bucketName } } } } } },
            '#withProvider':: d.fn(help='"Provider is a provider name. This field is immutable."', args=[d.arg(name='provider', type=d.T.string)]),
            withProvider(provider): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { provider: provider } } } } } },
            '#withProviderConfig':: d.fn(help='"ProviderConfig is the provider-specific configuration passed to BackupBucket resource."', args=[d.arg(name='providerConfig', type=d.T.object)]),
            withProviderConfig(providerConfig): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { providerConfig: providerConfig } } } } } },
            '#withProviderConfigMixin':: d.fn(help='"ProviderConfig is the provider-specific configuration passed to BackupBucket resource."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='providerConfig', type=d.T.object)]),
            withProviderConfigMixin(providerConfig): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { providerConfig+: providerConfig } } } } } },
            '#withRegion':: d.fn(help='"Region is a region name. If undefined, the provider region is used. This field is immutable."', args=[d.arg(name='region', type=d.T.string)]),
            withRegion(region): { spec+: { virtualCluster+: { etcd+: { main+: { backup+: { region: region } } } } } },
          },
          '#storage':: d.obj(help='"Storage contains storage configuration."'),
          storage: {
            '#withCapacity':: d.fn(help='"Capacity is the storage capacity for the volumes."', args=[d.arg(name='capacity', type=d.T.any)]),
            withCapacity(capacity): { spec+: { virtualCluster+: { etcd+: { main+: { storage+: { capacity: capacity } } } } } },
            '#withClassName':: d.fn(help='"ClassName is the name of a storage class."', args=[d.arg(name='className', type=d.T.string)]),
            withClassName(className): { spec+: { virtualCluster+: { etcd+: { main+: { storage+: { className: className } } } } } },
          },
        },
      },
      '#gardener':: d.obj(help='"Gardener contains the configuration options for the Gardener control plane components."'),
      gardener: {
        '#gardenerAPIServer':: d.obj(help='"APIServer contains configuration settings for the gardener-apiserver."'),
        gardenerAPIServer: {
          '#admissionPlugins':: d.obj(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener),\\nand, if desired, the corresponding configuration."'),
          admissionPlugins: {
            '#withConfig':: d.fn(help='"Config is the configuration of the plugin."', args=[d.arg(name='config', type=d.T.object)]),
            withConfig(config): { config: config },
            '#withConfigMixin':: d.fn(help='"Config is the configuration of the plugin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
            withConfigMixin(config): { config+: config },
            '#withDisabled':: d.fn(help='"Disabled specifies whether this plugin should be disabled."', args=[d.arg(name='disabled', type=d.T.boolean)]),
            withDisabled(disabled): { disabled: disabled },
            '#withKubeconfigSecretName':: d.fn(help='"KubeconfigSecretName specifies the name of a secret containing the kubeconfig for this admission plugin."', args=[d.arg(name='kubeconfigSecretName', type=d.T.string)]),
            withKubeconfigSecretName(kubeconfigSecretName): { kubeconfigSecretName: kubeconfigSecretName },
            '#withName':: d.fn(help='"Name is the name of the plugin."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#auditConfig':: d.obj(help='"AuditConfig contains configuration settings for the audit of the kube-apiserver."'),
          auditConfig: {
            '#auditPolicy':: d.obj(help='"AuditPolicy contains configuration settings for audit policy of the kube-apiserver."'),
            auditPolicy: {
              '#configMapRef':: d.obj(help='"ConfigMapRef is a reference to a ConfigMap object in the same namespace,\\nwhich contains the audit policy for the kube-apiserver."'),
              configMapRef: {
                '#withApiVersion':: d.fn(help='"API version of the referent."', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { apiVersion: apiVersion } } } } } } } },
                '#withFieldPath':: d.fn(help='"If referring to a piece of an object instead of an entire object, this string\\nshould contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\\nFor example, if the object reference is to a container within a pod, this would take on a value like:\\n\\"spec.containers{name}\\" (where \\"name\\" refers to the name of the container that triggered\\nthe event) or if no container name is specified \\"spec.containers[2]\\" (container with\\nindex 2 in this pod). This syntax is chosen only to have some well-defined way of\\nreferencing a part of an object."', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { fieldPath: fieldPath } } } } } } } },
                '#withKind':: d.fn(help='"Kind of the referent.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { kind: kind } } } } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { name: name } } } } } } } },
                '#withNamespace':: d.fn(help='"Namespace of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { namespace: namespace } } } } } } } },
                '#withResourceVersion':: d.fn(help='"Specific resourceVersion to which this reference is made, if any.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
                withResourceVersion(resourceVersion): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { resourceVersion: resourceVersion } } } } } } } },
                '#withUid':: d.fn(help='"UID of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"', args=[d.arg(name='uid', type=d.T.string)]),
                withUid(uid): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { uid: uid } } } } } } } },
              },
            },
          },
          '#auditWebhook':: d.obj(help='"AuditWebhook contains settings related to an audit webhook configuration."'),
          auditWebhook: {
            '#withBatchMaxSize':: d.fn(help='"BatchMaxSize is the maximum size of a batch."', args=[d.arg(name='batchMaxSize', type=d.T.integer)]),
            withBatchMaxSize(batchMaxSize): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditWebhook+: { batchMaxSize: batchMaxSize } } } } } },
            '#withKubeconfigSecretName':: d.fn(help='"KubeconfigSecretName specifies the name of a secret containing the kubeconfig for this webhook."', args=[d.arg(name='kubeconfigSecretName', type=d.T.string)]),
            withKubeconfigSecretName(kubeconfigSecretName): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditWebhook+: { kubeconfigSecretName: kubeconfigSecretName } } } } } },
            '#withVersion':: d.fn(help='"Version is the API version to send and expect from the webhook."', args=[d.arg(name='version', type=d.T.string)]),
            withVersion(version): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { auditWebhook+: { version: version } } } } } },
          },
          '#encryptionConfig':: d.obj(help='"EncryptionConfig contains customizable encryption configuration of the Gardener API server."'),
          encryptionConfig: {
            '#withResources':: d.fn(help='"Resources contains the list of resources that shall be encrypted in addition to secrets.\\nEach item is a Kubernetes resource name in plural (resource or resource.group) that should be encrypted.\\nWildcards are not supported for now.\\nSee https://github.com/gardener/gardener/blob/master/docs/usage/security/etcd_encryption_config.md for more details."', args=[d.arg(name='resources', type=d.T.array)]),
            withResources(resources): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { encryptionConfig+: { resources: if std.isArray(v=resources) then resources else [resources] } } } } } },
            '#withResourcesMixin':: d.fn(help='"Resources contains the list of resources that shall be encrypted in addition to secrets.\\nEach item is a Kubernetes resource name in plural (resource or resource.group) that should be encrypted.\\nWildcards are not supported for now.\\nSee https://github.com/gardener/gardener/blob/master/docs/usage/security/etcd_encryption_config.md for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resources', type=d.T.array)]),
            withResourcesMixin(resources): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { encryptionConfig+: { resources+: if std.isArray(v=resources) then resources else [resources] } } } } } },
          },
          '#logging':: d.obj(help='"Logging contains configuration for the log level and HTTP access logs."'),
          logging: {
            '#withHttpAccessVerbosity':: d.fn(help='"HTTPAccessVerbosity is the kube-apiserver access logs level"', args=[d.arg(name='httpAccessVerbosity', type=d.T.integer)]),
            withHttpAccessVerbosity(httpAccessVerbosity): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { logging+: { httpAccessVerbosity: httpAccessVerbosity } } } } } },
            '#withVerbosity':: d.fn(help='"Verbosity is the kube-apiserver log verbosity level\\nDefaults to 2."', args=[d.arg(name='verbosity', type=d.T.integer)]),
            withVerbosity(verbosity): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { logging+: { verbosity: verbosity } } } } } },
          },
          '#requests':: d.obj(help='"Requests contains configuration for request-specific settings for the kube-apiserver."'),
          requests: {
            '#withMaxMutatingInflight':: d.fn(help='"MaxMutatingInflight is the maximum number of mutating requests in flight at a given time. When the server\\nexceeds this, it rejects requests."', args=[d.arg(name='maxMutatingInflight', type=d.T.integer)]),
            withMaxMutatingInflight(maxMutatingInflight): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { requests+: { maxMutatingInflight: maxMutatingInflight } } } } } },
            '#withMaxNonMutatingInflight':: d.fn(help='"MaxNonMutatingInflight is the maximum number of non-mutating requests in flight at a given time. When the server\\nexceeds this, it rejects requests."', args=[d.arg(name='maxNonMutatingInflight', type=d.T.integer)]),
            withMaxNonMutatingInflight(maxNonMutatingInflight): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { requests+: { maxNonMutatingInflight: maxNonMutatingInflight } } } } } },
          },
          '#watchCacheSizes':: d.obj(help="\"WatchCacheSizes contains configuration of the API server's watch cache sizes.\\nConfiguring these flags might be useful for large-scale Garden clusters with a lot of parallel update requests\\nand a lot of watching controllers (e.g. large ManagedSeed clusters). When the API server's watch cache's\\ncapacity is too small to cope with the amount of update requests and watchers for a particular resource, it\\nmight happen that controller watches are permanently stopped with `too old resource version` errors.\\nStarting from kubernetes v1.19, the API server's watch cache size is adapted dynamically and setting the watch\\ncache size flags will have no effect, except when setting it to 0 (which disables the watch cache).\""),
          watchCacheSizes: {
            '#resources':: d.obj(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"'),
            resources: {
              '#withApiGroup':: d.fn(help='"APIGroup is the API group of the resource for which the watch cache size should be configured.\\nAn unset value is used to specify the legacy core API (e.g. for `secrets`)."', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { apiGroup: apiGroup },
              '#withResource':: d.fn(help='"Resource is the name of the resource for which the watch cache size should be configured\\n(in lowercase plural form, e.g. `secrets`)."', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resource: resource },
              '#withSize':: d.fn(help='"CacheSize specifies the watch cache size that should be configured for the specified resource."', args=[d.arg(name='size', type=d.T.integer)]),
              withSize(size): { size: size },
            },
            '#withDefault':: d.fn(help='"Default configures the default watch cache size of the kube-apiserver\\n(flag `--default-watch-cache-size`, defaults to 100).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"', args=[d.arg(name='default', type=d.T.integer)]),
            withDefault(default): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { watchCacheSizes+: { default: default } } } } } },
            '#withResources':: d.fn(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"', args=[d.arg(name='resources', type=d.T.array)]),
            withResources(resources): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { watchCacheSizes+: { resources: if std.isArray(v=resources) then resources else [resources] } } } } } },
            '#withResourcesMixin':: d.fn(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resources', type=d.T.array)]),
            withResourcesMixin(resources): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { watchCacheSizes+: { resources+: if std.isArray(v=resources) then resources else [resources] } } } } } },
          },
          '#withAdmissionPlugins':: d.fn(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener),\\nand, if desired, the corresponding configuration."', args=[d.arg(name='admissionPlugins', type=d.T.array)]),
          withAdmissionPlugins(admissionPlugins): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { admissionPlugins: if std.isArray(v=admissionPlugins) then admissionPlugins else [admissionPlugins] } } } } },
          '#withAdmissionPluginsMixin':: d.fn(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener),\\nand, if desired, the corresponding configuration."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='admissionPlugins', type=d.T.array)]),
          withAdmissionPluginsMixin(admissionPlugins): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { admissionPlugins+: if std.isArray(v=admissionPlugins) then admissionPlugins else [admissionPlugins] } } } } },
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { featureGates+: featureGates } } } } },
          '#withGoAwayChance':: d.fn(help="\"GoAwayChance can be used to prevent HTTP/2 clients from getting stuck on a single apiserver, randomly close a\\nconnection (GOAWAY). The client's other in-flight requests won't be affected, and the client will reconnect,\\nlikely landing on a different apiserver after going through the load balancer again. This field sets the fraction\\nof requests that will be sent a GOAWAY. Min is 0 (off), Max is 0.02 (1/50 requests); 0.001 (1/1000) is a\\nrecommended starting point.\"", args=[d.arg(name='goAwayChance', type=d.T.number)]),
          withGoAwayChance(goAwayChance): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { goAwayChance: goAwayChance } } } } },
          '#withShootAdminKubeconfigMaxExpiration':: d.fn(help='"ShootAdminKubeconfigMaxExpiration is the maximum validity duration of a credential requested to a Shoot by an AdminKubeconfigRequest.\\nIf an otherwise valid AdminKubeconfigRequest with a validity duration larger than this value is requested,\\na credential will be issued with a validity duration of this value."', args=[d.arg(name='shootAdminKubeconfigMaxExpiration', type=d.T.string)]),
          withShootAdminKubeconfigMaxExpiration(shootAdminKubeconfigMaxExpiration): { spec+: { virtualCluster+: { gardener+: { gardenerAPIServer+: { shootAdminKubeconfigMaxExpiration: shootAdminKubeconfigMaxExpiration } } } } },
        },
        '#gardenerAdmissionController':: d.obj(help='"AdmissionController contains configuration settings for the gardener-admission-controller."'),
        gardenerAdmissionController: {
          '#resourceAdmissionConfiguration':: d.obj(help='"ResourceAdmissionConfiguration is the configuration for resource size restrictions for arbitrary Group-Version-Kinds."'),
          resourceAdmissionConfiguration: {
            '#limits':: d.obj(help='"Limits contains configuration for resources which are subjected to size limitations."'),
            limits: {
              '#withApiGroups':: d.fn(help='"APIGroups is the name of the APIGroup that contains the limited resource. WildcardAll represents all groups."', args=[d.arg(name='apiGroups', type=d.T.array)]),
              withApiGroups(apiGroups): { apiGroups: if std.isArray(v=apiGroups) then apiGroups else [apiGroups] },
              '#withApiGroupsMixin':: d.fn(help='"APIGroups is the name of the APIGroup that contains the limited resource. WildcardAll represents all groups."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='apiGroups', type=d.T.array)]),
              withApiGroupsMixin(apiGroups): { apiGroups+: if std.isArray(v=apiGroups) then apiGroups else [apiGroups] },
              '#withApiVersions':: d.fn(help='"APIVersions is the version of the resource. WildcardAll represents all versions."', args=[d.arg(name='apiVersions', type=d.T.array)]),
              withApiVersions(apiVersions): { apiVersions: if std.isArray(v=apiVersions) then apiVersions else [apiVersions] },
              '#withApiVersionsMixin':: d.fn(help='"APIVersions is the version of the resource. WildcardAll represents all versions."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='apiVersions', type=d.T.array)]),
              withApiVersionsMixin(apiVersions): { apiVersions+: if std.isArray(v=apiVersions) then apiVersions else [apiVersions] },
              '#withCount':: d.fn(help='"Count specifies the maximum number of resources of the given kind. Only cluster-scoped resources are considered."', args=[d.arg(name='count', type=d.T.integer)]),
              withCount(count): { count: count },
              '#withResources':: d.fn(help='"Resources is the name of the resource this rule applies to. WildcardAll represents all resources."', args=[d.arg(name='resources', type=d.T.array)]),
              withResources(resources): { resources: if std.isArray(v=resources) then resources else [resources] },
              '#withResourcesMixin':: d.fn(help='"Resources is the name of the resource this rule applies to. WildcardAll represents all resources."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resources', type=d.T.array)]),
              withResourcesMixin(resources): { resources+: if std.isArray(v=resources) then resources else [resources] },
              '#withSize':: d.fn(help='"Size specifies the imposed limit."', args=[d.arg(name='size', type=d.T.any)]),
              withSize(size): { size: size },
            },
            '#unrestrictedSubjects':: d.obj(help="\"UnrestrictedSubjects contains references to users, groups, or service accounts which aren't subjected to any resource size limit.\""),
            unrestrictedSubjects: {
              '#withApiGroup':: d.fn(help='"APIGroup holds the API group of the referenced subject.\\nDefaults to \\"\\" for ServiceAccount subjects.\\nDefaults to \\"rbac.authorization.k8s.io\\" for User and Group subjects."', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { apiGroup: apiGroup },
              '#withKind':: d.fn(help='"Kind of object being referenced. Values defined by this API group are \\"User\\", \\"Group\\", and \\"ServiceAccount\\".\\nIf the Authorizer does not recognized the kind value, the Authorizer should report an error."', args=[d.arg(name='kind', type=d.T.string)]),
              withKind(kind): { kind: kind },
              '#withName':: d.fn(help='"Name of the object being referenced."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withNamespace':: d.fn(help='"Namespace of the referenced object.  If the object kind is non-namespace, such as \\"User\\" or \\"Group\\", and this value is not empty\\nthe Authorizer should report an error."', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { namespace: namespace },
            },
            '#withLimits':: d.fn(help='"Limits contains configuration for resources which are subjected to size limitations."', args=[d.arg(name='limits', type=d.T.array)]),
            withLimits(limits): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { resourceAdmissionConfiguration+: { limits: if std.isArray(v=limits) then limits else [limits] } } } } } },
            '#withLimitsMixin':: d.fn(help='"Limits contains configuration for resources which are subjected to size limitations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.array)]),
            withLimitsMixin(limits): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { resourceAdmissionConfiguration+: { limits+: if std.isArray(v=limits) then limits else [limits] } } } } } },
            '#withOperationMode':: d.fn(help='"OperationMode specifies the mode the webhooks operates in. Allowed values are \\"block\\" and \\"log\\". Defaults to \\"block\\"."', args=[d.arg(name='operationMode', type=d.T.string)]),
            withOperationMode(operationMode): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { resourceAdmissionConfiguration+: { operationMode: operationMode } } } } } },
            '#withUnrestrictedSubjects':: d.fn(help="\"UnrestrictedSubjects contains references to users, groups, or service accounts which aren't subjected to any resource size limit.\"", args=[d.arg(name='unrestrictedSubjects', type=d.T.array)]),
            withUnrestrictedSubjects(unrestrictedSubjects): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { resourceAdmissionConfiguration+: { unrestrictedSubjects: if std.isArray(v=unrestrictedSubjects) then unrestrictedSubjects else [unrestrictedSubjects] } } } } } },
            '#withUnrestrictedSubjectsMixin':: d.fn(help="\"UnrestrictedSubjects contains references to users, groups, or service accounts which aren't subjected to any resource size limit.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='unrestrictedSubjects', type=d.T.array)]),
            withUnrestrictedSubjectsMixin(unrestrictedSubjects): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { resourceAdmissionConfiguration+: { unrestrictedSubjects+: if std.isArray(v=unrestrictedSubjects) then unrestrictedSubjects else [unrestrictedSubjects] } } } } } },
          },
          '#withLogLevel':: d.fn(help='"LogLevel is the configured log level for the gardener-admission-controller. Must be one of [info,debug,error].\\nDefaults to info."', args=[d.arg(name='logLevel', type=d.T.string)]),
          withLogLevel(logLevel): { spec+: { virtualCluster+: { gardener+: { gardenerAdmissionController+: { logLevel: logLevel } } } } },
        },
        '#gardenerControllerManager':: d.obj(help='"ControllerManager contains configuration settings for the gardener-controller-manager."'),
        gardenerControllerManager: {
          '#defaultProjectQuotas':: d.obj(help='"DefaultProjectQuotas is the default configuration matching projects are set up with if a quota is not already\\nspecified."'),
          defaultProjectQuotas: {
            '#config':: d.obj(help='"Config is the corev1.ResourceQuota specification used for the project set-up."'),
            config: {
              '#spec':: d.obj(help='"Spec defines the desired quota.\\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status"'),
              spec: {
                '#scopeSelector':: d.obj(help='"scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota\\nbut expressed using ScopeSelectorOperator in combination with possible values.\\nFor a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched."'),
                scopeSelector: {
                  '#matchExpressions':: d.obj(help='"A list of scope selector requirements by scope of the resources."'),
                  matchExpressions: {
                    '#withOperator':: d.fn(help="\"Represents a scope's relationship to a set of values.\\nValid operators are In, NotIn, Exists, DoesNotExist.\"", args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withScopeName':: d.fn(help='"The name of the scope that the selector applies to."', args=[d.arg(name='scopeName', type=d.T.string)]),
                    withScopeName(scopeName): { scopeName: scopeName },
                    '#withValues':: d.fn(help='"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty.\\nThis array is replaced during a strategic merge patch."', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty.\\nThis array is replaced during a strategic merge patch."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='"A list of scope selector requirements by scope of the resources."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { config+: { spec+: { scopeSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
                  '#withMatchExpressionsMixin':: d.fn(help='"A list of scope selector requirements by scope of the resources."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { config+: { spec+: { scopeSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
                },
                '#withHard':: d.fn(help='"hard is the set of desired hard limits for each named resource.\\nMore info: https://kubernetes.io/docs/concepts/policy/resource-quotas/"', args=[d.arg(name='hard', type=d.T.object)]),
                withHard(hard): { config+: { spec+: { hard: hard } } },
                '#withHardMixin':: d.fn(help='"hard is the set of desired hard limits for each named resource.\\nMore info: https://kubernetes.io/docs/concepts/policy/resource-quotas/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hard', type=d.T.object)]),
                withHardMixin(hard): { config+: { spec+: { hard+: hard } } },
                '#withScopes':: d.fn(help='"A collection of filters that must match each object tracked by a quota.\\nIf not specified, the quota matches all objects."', args=[d.arg(name='scopes', type=d.T.array)]),
                withScopes(scopes): { config+: { spec+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
                '#withScopesMixin':: d.fn(help='"A collection of filters that must match each object tracked by a quota.\\nIf not specified, the quota matches all objects."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
                withScopesMixin(scopes): { config+: { spec+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
              },
              '#withApiVersion':: d.fn(help='"APIVersion defines the versioned schema of this representation of an object.\\nServers should convert recognized schemas to the latest internal value, and\\nmay reject unrecognized values.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { config+: { apiVersion: apiVersion } },
              '#withKind':: d.fn(help='"Kind is a string value representing the REST resource this object represents.\\nServers may infer this from the endpoint the client submits requests to.\\nCannot be updated.\\nIn CamelCase.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"', args=[d.arg(name='kind', type=d.T.string)]),
              withKind(kind): { config+: { kind: kind } },
              '#withMetadata':: d.fn(help="\"Standard object's metadata.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\"", args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadata(metadata): { config+: { metadata: metadata } },
              '#withMetadataMixin':: d.fn(help="\"Standard object's metadata.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadataMixin(metadata): { config+: { metadata+: metadata } },
            },
            '#projectSelector':: d.obj(help='"ProjectSelector is an optional setting to select the projects considered for quotas.\\nDefaults to empty LabelSelector, which matches all projects."'),
            projectSelector: {
              '#matchExpressions':: d.obj(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."'),
              matchExpressions: {
                '#withKey':: d.fn(help='"key is the label key that the selector applies to."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help="\"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\"", args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch."', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { projectSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { projectSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\"key\\", the\\noperator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { projectSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\"key\\", the\\noperator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { projectSelector+: { matchLabels+: matchLabels } },
            },
          },
          '#withDefaultProjectQuotas':: d.fn(help='"DefaultProjectQuotas is the default configuration matching projects are set up with if a quota is not already\\nspecified."', args=[d.arg(name='defaultProjectQuotas', type=d.T.array)]),
          withDefaultProjectQuotas(defaultProjectQuotas): { spec+: { virtualCluster+: { gardener+: { gardenerControllerManager+: { defaultProjectQuotas: if std.isArray(v=defaultProjectQuotas) then defaultProjectQuotas else [defaultProjectQuotas] } } } } },
          '#withDefaultProjectQuotasMixin':: d.fn(help='"DefaultProjectQuotas is the default configuration matching projects are set up with if a quota is not already\\nspecified."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='defaultProjectQuotas', type=d.T.array)]),
          withDefaultProjectQuotasMixin(defaultProjectQuotas): { spec+: { virtualCluster+: { gardener+: { gardenerControllerManager+: { defaultProjectQuotas+: if std.isArray(v=defaultProjectQuotas) then defaultProjectQuotas else [defaultProjectQuotas] } } } } },
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerControllerManager+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerControllerManager+: { featureGates+: featureGates } } } } },
          '#withLogLevel':: d.fn(help='"LogLevel is the configured log level for the gardener-controller-manager. Must be one of [info,debug,error].\\nDefaults to info."', args=[d.arg(name='logLevel', type=d.T.string)]),
          withLogLevel(logLevel): { spec+: { virtualCluster+: { gardener+: { gardenerControllerManager+: { logLevel: logLevel } } } } },
        },
        '#gardenerDashboard':: d.obj(help='"Dashboard contains configuration settings for the gardener-dashboard."'),
        gardenerDashboard: {
          '#assetsConfigMapRef':: d.obj(help='"AssetsConfigMapRef is the reference to a ConfigMap in the garden namespace containing the assets (logos/icons)."'),
          assetsConfigMapRef: {
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { assetsConfigMapRef+: { name: name } } } } } },
          },
          '#frontendConfigMapRef':: d.obj(help='"FrontendConfigMapRef is the reference to a ConfigMap in the garden namespace containing the frontend\\nconfiguration."'),
          frontendConfigMapRef: {
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { frontendConfigMapRef+: { name: name } } } } } },
          },
          '#gitHub':: d.obj(help='"GitHub contains configuration for the GitHub ticketing feature."'),
          gitHub: {
            '#secretRef':: d.obj(help='"SecretRef is the reference to a secret in the garden namespace containing the GitHub credentials."'),
            secretRef: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { gitHub+: { secretRef+: { name: name } } } } } } },
            },
            '#withApiURL':: d.fn(help='"APIURL is the URL to the GitHub API."', args=[d.arg(name='apiURL', type=d.T.string)]),
            withApiURL(apiURL): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { gitHub+: { apiURL: apiURL } } } } } },
            '#withOrganisation':: d.fn(help='"Organisation is the name of the GitHub organisation."', args=[d.arg(name='organisation', type=d.T.string)]),
            withOrganisation(organisation): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { gitHub+: { organisation: organisation } } } } } },
            '#withPollInterval':: d.fn(help="\"PollInterval is the interval of how often the GitHub API is polled for issue updates. This field is used as a\\nfallback mechanism to ensure state synchronization, even when there is a GitHub webhook configuration. If a\\nwebhook event is missed or not successfully delivered, the polling will help catch up on any missed updates.\\nIf this field is not provided and there is no 'webhookSecret' key in the referenced secret, it will be\\nimplicitly defaulted to `15m`.\"", args=[d.arg(name='pollInterval', type=d.T.string)]),
            withPollInterval(pollInterval): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { gitHub+: { pollInterval: pollInterval } } } } } },
            '#withRepository':: d.fn(help='"Repository is the name of the GitHub repository."', args=[d.arg(name='repository', type=d.T.string)]),
            withRepository(repository): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { gitHub+: { repository: repository } } } } } },
          },
          '#ingress':: d.obj(help='"Ingress contains configuration for the ingress settings."'),
          ingress: {
            '#withEnabled':: d.fn(help='"Enabled controls whether the Dashboard Ingress resource will be deployed to the cluster."', args=[d.arg(name='enabled', type=d.T.boolean)]),
            withEnabled(enabled): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { ingress+: { enabled: enabled } } } } } },
          },
          '#oidcConfig':: d.obj(help='"OIDCConfig contains configuration for the OIDC provider. This field must be provided when EnableTokenLogin is false."'),
          oidcConfig: {
            '#certificateAuthoritySecretRef':: d.obj(help='"CertificateAuthoritySecretRef is the reference to a secret in the garden namespace containing a custom CA certificate under the \\"ca.crt\\" key"'),
            certificateAuthoritySecretRef: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { certificateAuthoritySecretRef+: { name: name } } } } } } },
            },
            '#secretRef':: d.obj(help='"SecretRef is the reference to a secret in the garden namespace containing the OIDC client ID and secret for the dashboard."'),
            secretRef: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { secretRef+: { name: name } } } } } } },
            },
            '#withAdditionalScopes':: d.fn(help='"AdditionalScopes is the list of additional OIDC scopes."', args=[d.arg(name='additionalScopes', type=d.T.array)]),
            withAdditionalScopes(additionalScopes): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { additionalScopes: if std.isArray(v=additionalScopes) then additionalScopes else [additionalScopes] } } } } } },
            '#withAdditionalScopesMixin':: d.fn(help='"AdditionalScopes is the list of additional OIDC scopes."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='additionalScopes', type=d.T.array)]),
            withAdditionalScopesMixin(additionalScopes): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { additionalScopes+: if std.isArray(v=additionalScopes) then additionalScopes else [additionalScopes] } } } } } },
            '#withClientIDPublic':: d.fn(help="\"ClientIDPublic is the public client ID.\\nFalls back to the API server's OIDC client ID configuration if not set here.\"", args=[d.arg(name='clientIDPublic', type=d.T.string)]),
            withClientIDPublic(clientIDPublic): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { clientIDPublic: clientIDPublic } } } } } },
            '#withIssuerURL':: d.fn(help="\"The URL of the OpenID issuer, only HTTPS scheme will be accepted. Used to verify the OIDC JSON Web Token (JWT).\\nFalls back to the API server's OIDC issuer URL configuration if not set here.\"", args=[d.arg(name='issuerURL', type=d.T.string)]),
            withIssuerURL(issuerURL): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { issuerURL: issuerURL } } } } } },
            '#withSessionLifetime':: d.fn(help='"SessionLifetime is the maximum duration of a session."', args=[d.arg(name='sessionLifetime', type=d.T.string)]),
            withSessionLifetime(sessionLifetime): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { oidcConfig+: { sessionLifetime: sessionLifetime } } } } } },
          },
          '#terminal':: d.obj(help='"Terminal contains configuration for the terminal settings."'),
          terminal: {
            '#container':: d.obj(help='"Container contains configuration for the dashboard terminal container."'),
            container: {
              '#withDescription':: d.fn(help='"Description is a description for the dashboard terminal container with hints for the user."', args=[d.arg(name='description', type=d.T.string)]),
              withDescription(description): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { terminal+: { container+: { description: description } } } } } } },
              '#withImage':: d.fn(help='"Image is the container image for the dashboard terminal container."', args=[d.arg(name='image', type=d.T.string)]),
              withImage(image): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { terminal+: { container+: { image: image } } } } } } },
            },
            '#withAllowedHosts':: d.fn(help="\"AllowedHosts should consist of permitted hostnames (without the scheme) for terminal connections.\\nIt is important to consider that the usage of wildcards follows the rules defined by the content security policy.\\n'*.seed.local.gardener.cloud', or '*.other-seeds.local.gardener.cloud'. For more information, see\\nhttps://github.com/gardener/dashboard/blob/master/docs/operations/webterminals.md#allowlist-for-hosts.\"", args=[d.arg(name='allowedHosts', type=d.T.array)]),
            withAllowedHosts(allowedHosts): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { terminal+: { allowedHosts: if std.isArray(v=allowedHosts) then allowedHosts else [allowedHosts] } } } } } },
            '#withAllowedHostsMixin':: d.fn(help="\"AllowedHosts should consist of permitted hostnames (without the scheme) for terminal connections.\\nIt is important to consider that the usage of wildcards follows the rules defined by the content security policy.\\n'*.seed.local.gardener.cloud', or '*.other-seeds.local.gardener.cloud'. For more information, see\\nhttps://github.com/gardener/dashboard/blob/master/docs/operations/webterminals.md#allowlist-for-hosts.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='allowedHosts', type=d.T.array)]),
            withAllowedHostsMixin(allowedHosts): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { terminal+: { allowedHosts+: if std.isArray(v=allowedHosts) then allowedHosts else [allowedHosts] } } } } } },
          },
          '#withEnableTokenLogin':: d.fn(help='"EnableTokenLogin specifies whether it is possible to log into the dashboard with a JWT token. If disabled, OIDC\\nmust be configured."', args=[d.arg(name='enableTokenLogin', type=d.T.boolean)]),
          withEnableTokenLogin(enableTokenLogin): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { enableTokenLogin: enableTokenLogin } } } } },
          '#withLogLevel':: d.fn(help='"LogLevel is the configured log level. Must be one of [trace,debug,info,warn,error].\\nDefaults to info."', args=[d.arg(name='logLevel', type=d.T.string)]),
          withLogLevel(logLevel): { spec+: { virtualCluster+: { gardener+: { gardenerDashboard+: { logLevel: logLevel } } } } },
        },
        '#gardenerScheduler':: d.obj(help='"Scheduler contains configuration settings for the gardener-scheduler."'),
        gardenerScheduler: {
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerScheduler+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { virtualCluster+: { gardener+: { gardenerScheduler+: { featureGates+: featureGates } } } } },
          '#withLogLevel':: d.fn(help='"LogLevel is the configured log level for the gardener-scheduler. Must be one of [info,debug,error].\\nDefaults to info."', args=[d.arg(name='logLevel', type=d.T.string)]),
          withLogLevel(logLevel): { spec+: { virtualCluster+: { gardener+: { gardenerScheduler+: { logLevel: logLevel } } } } },
        },
        '#withClusterIdentity':: d.fn(help='"ClusterIdentity is the identity of the garden cluster. This field is immutable."', args=[d.arg(name='clusterIdentity', type=d.T.string)]),
        withClusterIdentity(clusterIdentity): { spec+: { virtualCluster+: { gardener+: { clusterIdentity: clusterIdentity } } } },
        '#withGardenerDiscoveryServer':: d.fn(help='"DiscoveryServer contains configuration settings for the gardener-discovery-server."', args=[d.arg(name='gardenerDiscoveryServer', type=d.T.object)]),
        withGardenerDiscoveryServer(gardenerDiscoveryServer): { spec+: { virtualCluster+: { gardener+: { gardenerDiscoveryServer: gardenerDiscoveryServer } } } },
        '#withGardenerDiscoveryServerMixin':: d.fn(help='"DiscoveryServer contains configuration settings for the gardener-discovery-server."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='gardenerDiscoveryServer', type=d.T.object)]),
        withGardenerDiscoveryServerMixin(gardenerDiscoveryServer): { spec+: { virtualCluster+: { gardener+: { gardenerDiscoveryServer+: gardenerDiscoveryServer } } } },
      },
      '#kubernetes':: d.obj(help='"Kubernetes contains the version and configuration options for the Kubernetes components of the virtual garden\\ncluster."'),
      kubernetes: {
        '#kubeAPIServer':: d.obj(help='"KubeAPIServer contains configuration settings for the kube-apiserver."'),
        kubeAPIServer: {
          '#admissionPlugins':: d.obj(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener), and, if desired, the corresponding\\nconfiguration."'),
          admissionPlugins: {
            '#withConfig':: d.fn(help='"Config is the configuration of the plugin."', args=[d.arg(name='config', type=d.T.object)]),
            withConfig(config): { config: config },
            '#withConfigMixin':: d.fn(help='"Config is the configuration of the plugin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
            withConfigMixin(config): { config+: config },
            '#withDisabled':: d.fn(help='"Disabled specifies whether this plugin should be disabled."', args=[d.arg(name='disabled', type=d.T.boolean)]),
            withDisabled(disabled): { disabled: disabled },
            '#withKubeconfigSecretName':: d.fn(help='"KubeconfigSecretName specifies the name of a secret containing the kubeconfig for this admission plugin."', args=[d.arg(name='kubeconfigSecretName', type=d.T.string)]),
            withKubeconfigSecretName(kubeconfigSecretName): { kubeconfigSecretName: kubeconfigSecretName },
            '#withName':: d.fn(help='"Name is the name of the plugin."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#auditConfig':: d.obj(help='"AuditConfig contains configuration settings for the audit of the kube-apiserver."'),
          auditConfig: {
            '#auditPolicy':: d.obj(help='"AuditPolicy contains configuration settings for audit policy of the kube-apiserver."'),
            auditPolicy: {
              '#configMapRef':: d.obj(help='"ConfigMapRef is a reference to a ConfigMap object in the same namespace,\\nwhich contains the audit policy for the kube-apiserver."'),
              configMapRef: {
                '#withApiVersion':: d.fn(help='"API version of the referent."', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { apiVersion: apiVersion } } } } } } } },
                '#withFieldPath':: d.fn(help='"If referring to a piece of an object instead of an entire object, this string\\nshould contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\\nFor example, if the object reference is to a container within a pod, this would take on a value like:\\n\\"spec.containers{name}\\" (where \\"name\\" refers to the name of the container that triggered\\nthe event) or if no container name is specified \\"spec.containers[2]\\" (container with\\nindex 2 in this pod). This syntax is chosen only to have some well-defined way of\\nreferencing a part of an object."', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { fieldPath: fieldPath } } } } } } } },
                '#withKind':: d.fn(help='"Kind of the referent.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { kind: kind } } } } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { name: name } } } } } } } },
                '#withNamespace':: d.fn(help='"Namespace of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { namespace: namespace } } } } } } } },
                '#withResourceVersion':: d.fn(help='"Specific resourceVersion to which this reference is made, if any.\\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
                withResourceVersion(resourceVersion): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { resourceVersion: resourceVersion } } } } } } } },
                '#withUid':: d.fn(help='"UID of the referent.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"', args=[d.arg(name='uid', type=d.T.string)]),
                withUid(uid): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditConfig+: { auditPolicy+: { configMapRef+: { uid: uid } } } } } } } },
              },
            },
          },
          '#auditWebhook':: d.obj(help='"AuditWebhook contains settings related to an audit webhook configuration."'),
          auditWebhook: {
            '#withBatchMaxSize':: d.fn(help='"BatchMaxSize is the maximum size of a batch."', args=[d.arg(name='batchMaxSize', type=d.T.integer)]),
            withBatchMaxSize(batchMaxSize): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditWebhook+: { batchMaxSize: batchMaxSize } } } } } },
            '#withKubeconfigSecretName':: d.fn(help='"KubeconfigSecretName specifies the name of a secret containing the kubeconfig for this webhook."', args=[d.arg(name='kubeconfigSecretName', type=d.T.string)]),
            withKubeconfigSecretName(kubeconfigSecretName): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditWebhook+: { kubeconfigSecretName: kubeconfigSecretName } } } } } },
            '#withVersion':: d.fn(help='"Version is the API version to send and expect from the webhook."', args=[d.arg(name='version', type=d.T.string)]),
            withVersion(version): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { auditWebhook+: { version: version } } } } } },
          },
          '#authentication':: d.obj(help='"Authentication contains settings related to authentication."'),
          authentication: {
            '#webhook':: d.obj(help='"Webhook contains settings related to an authentication webhook configuration."'),
            webhook: {
              '#withCacheTTL':: d.fn(help='"CacheTTL is the duration to cache responses from the webhook authenticator."', args=[d.arg(name='cacheTTL', type=d.T.string)]),
              withCacheTTL(cacheTTL): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { authentication+: { webhook+: { cacheTTL: cacheTTL } } } } } } },
              '#withKubeconfigSecretName':: d.fn(help='"KubeconfigSecretName specifies the name of a secret containing the kubeconfig for this webhook."', args=[d.arg(name='kubeconfigSecretName', type=d.T.string)]),
              withKubeconfigSecretName(kubeconfigSecretName): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { authentication+: { webhook+: { kubeconfigSecretName: kubeconfigSecretName } } } } } } },
              '#withVersion':: d.fn(help='"Version is the API version to send and expect from the webhook."', args=[d.arg(name='version', type=d.T.string)]),
              withVersion(version): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { authentication+: { webhook+: { version: version } } } } } } },
            },
          },
          '#autoscaling':: d.obj(help='"Autoscaling contains auto-scaling configuration options for the kube-apiserver."'),
          autoscaling: {
            '#withMinAllowed':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowed(minAllowed): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { autoscaling+: { minAllowed: minAllowed } } } } } },
            '#withMinAllowedMixin':: d.fn(help='"MinAllowed configures the minimum allowed resource requests for vertical pod autoscaling..\\nConfiguration of minAllowed resources is an advanced feature that can help clusters to overcome scale-up delays.\\nDefault values are not applied to this field."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minAllowed', type=d.T.object)]),
            withMinAllowedMixin(minAllowed): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { autoscaling+: { minAllowed+: minAllowed } } } } } },
          },
          '#encryptionConfig':: d.obj(help='"EncryptionConfig contains customizable encryption configuration of the Kube API server."'),
          encryptionConfig: {
            '#withResources':: d.fn(help='"Resources contains the list of resources that shall be encrypted in addition to secrets.\\nEach item is a Kubernetes resource name in plural (resource or resource.group) that should be encrypted.\\nWildcards are not supported for now.\\nSee https://github.com/gardener/gardener/blob/master/docs/usage/security/etcd_encryption_config.md for more details."', args=[d.arg(name='resources', type=d.T.array)]),
            withResources(resources): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { encryptionConfig+: { resources: if std.isArray(v=resources) then resources else [resources] } } } } } },
            '#withResourcesMixin':: d.fn(help='"Resources contains the list of resources that shall be encrypted in addition to secrets.\\nEach item is a Kubernetes resource name in plural (resource or resource.group) that should be encrypted.\\nWildcards are not supported for now.\\nSee https://github.com/gardener/gardener/blob/master/docs/usage/security/etcd_encryption_config.md for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resources', type=d.T.array)]),
            withResourcesMixin(resources): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { encryptionConfig+: { resources+: if std.isArray(v=resources) then resources else [resources] } } } } } },
          },
          '#logging':: d.obj(help='"Logging contains configuration for the log level and HTTP access logs."'),
          logging: {
            '#withHttpAccessVerbosity':: d.fn(help='"HTTPAccessVerbosity is the kube-apiserver access logs level"', args=[d.arg(name='httpAccessVerbosity', type=d.T.integer)]),
            withHttpAccessVerbosity(httpAccessVerbosity): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { logging+: { httpAccessVerbosity: httpAccessVerbosity } } } } } },
            '#withVerbosity':: d.fn(help='"Verbosity is the kube-apiserver log verbosity level\\nDefaults to 2."', args=[d.arg(name='verbosity', type=d.T.integer)]),
            withVerbosity(verbosity): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { logging+: { verbosity: verbosity } } } } } },
          },
          '#oidcConfig':: d.obj(help='"OIDCConfig contains configuration settings for the OIDC provider.\\n\\nDeprecated: This field is deprecated and will be forbidden starting from Kubernetes 1.32.\\nPlease configure and use structured authentication instead of oidc flags.\\nFor more information check https://github.com/gardener/gardener/issues/9858"'),
          oidcConfig: {
            '#clientAuthentication':: d.obj(help="\"ClientAuthentication can optionally contain client configuration used for kubeconfig generation.\\n\\nDeprecated: This field has no implemented use and will be forbidden starting from Kubernetes 1.31.\\nIt's use was planned for generating OIDC kubeconfig https://github.com/gardener/gardener/issues/1433\""),
            clientAuthentication: {
              '#withExtraConfig':: d.fn(help="\"Extra configuration added to kubeconfig's auth-provider.\\nMust not be any of idp-issuer-url, client-id, client-secret, idp-certificate-authority, idp-certificate-authority-data, id-token or refresh-token\"", args=[d.arg(name='extraConfig', type=d.T.object)]),
              withExtraConfig(extraConfig): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { clientAuthentication+: { extraConfig: extraConfig } } } } } } },
              '#withExtraConfigMixin':: d.fn(help="\"Extra configuration added to kubeconfig's auth-provider.\\nMust not be any of idp-issuer-url, client-id, client-secret, idp-certificate-authority, idp-certificate-authority-data, id-token or refresh-token\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='extraConfig', type=d.T.object)]),
              withExtraConfigMixin(extraConfig): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { clientAuthentication+: { extraConfig+: extraConfig } } } } } } },
              '#withSecret':: d.fn(help='"The client Secret for the OpenID Connect client."', args=[d.arg(name='secret', type=d.T.string)]),
              withSecret(secret): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { clientAuthentication+: { secret: secret } } } } } } },
            },
            '#withCaBundle':: d.fn(help="\"If set, the OpenID server's certificate will be verified by one of the authorities in the oidc-ca-file, otherwise the host's root CA set will be used.\"", args=[d.arg(name='caBundle', type=d.T.string)]),
            withCaBundle(caBundle): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { caBundle: caBundle } } } } } },
            '#withClientID':: d.fn(help='"The client ID for the OpenID Connect client, must be set."', args=[d.arg(name='clientID', type=d.T.string)]),
            withClientID(clientID): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { clientID: clientID } } } } } },
            '#withGroupsClaim':: d.fn(help='"If provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings. This flag is experimental, please see the authentication documentation for further details."', args=[d.arg(name='groupsClaim', type=d.T.string)]),
            withGroupsClaim(groupsClaim): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { groupsClaim: groupsClaim } } } } } },
            '#withGroupsPrefix':: d.fn(help='"If provided, all groups will be prefixed with this value to prevent conflicts with other authentication strategies."', args=[d.arg(name='groupsPrefix', type=d.T.string)]),
            withGroupsPrefix(groupsPrefix): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { groupsPrefix: groupsPrefix } } } } } },
            '#withIssuerURL':: d.fn(help='"The URL of the OpenID issuer, only HTTPS scheme will be accepted. Used to verify the OIDC JSON Web Token (JWT)."', args=[d.arg(name='issuerURL', type=d.T.string)]),
            withIssuerURL(issuerURL): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { issuerURL: issuerURL } } } } } },
            '#withRequiredClaims':: d.fn(help='"key=value pairs that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value."', args=[d.arg(name='requiredClaims', type=d.T.object)]),
            withRequiredClaims(requiredClaims): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { requiredClaims: requiredClaims } } } } } },
            '#withRequiredClaimsMixin':: d.fn(help='"key=value pairs that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredClaims', type=d.T.object)]),
            withRequiredClaimsMixin(requiredClaims): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { requiredClaims+: requiredClaims } } } } } },
            '#withSigningAlgs':: d.fn(help="\"List of allowed JOSE asymmetric signing algorithms. JWTs with a 'alg' header value not in this list will be rejected. Values are defined by RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1\"", args=[d.arg(name='signingAlgs', type=d.T.array)]),
            withSigningAlgs(signingAlgs): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { signingAlgs: if std.isArray(v=signingAlgs) then signingAlgs else [signingAlgs] } } } } } },
            '#withSigningAlgsMixin':: d.fn(help="\"List of allowed JOSE asymmetric signing algorithms. JWTs with a 'alg' header value not in this list will be rejected. Values are defined by RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='signingAlgs', type=d.T.array)]),
            withSigningAlgsMixin(signingAlgs): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { signingAlgs+: if std.isArray(v=signingAlgs) then signingAlgs else [signingAlgs] } } } } } },
            '#withUsernameClaim':: d.fn(help="\"The OpenID claim to use as the user name. Note that claims other than the default ('sub') is not guaranteed to be unique and immutable. This flag is experimental, please see the authentication documentation for further details. (default \\\"sub\\\")\"", args=[d.arg(name='usernameClaim', type=d.T.string)]),
            withUsernameClaim(usernameClaim): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { usernameClaim: usernameClaim } } } } } },
            '#withUsernamePrefix':: d.fn(help="\"If provided, all usernames will be prefixed with this value. If not provided, username claims other than 'email' are prefixed by the issuer URL to avoid clashes. To skip any prefixing, provide the value '-'.\"", args=[d.arg(name='usernamePrefix', type=d.T.string)]),
            withUsernamePrefix(usernamePrefix): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { oidcConfig+: { usernamePrefix: usernamePrefix } } } } } },
          },
          '#requests':: d.obj(help='"Requests contains configuration for request-specific settings for the kube-apiserver."'),
          requests: {
            '#withMaxMutatingInflight':: d.fn(help='"MaxMutatingInflight is the maximum number of mutating requests in flight at a given time. When the server\\nexceeds this, it rejects requests."', args=[d.arg(name='maxMutatingInflight', type=d.T.integer)]),
            withMaxMutatingInflight(maxMutatingInflight): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { requests+: { maxMutatingInflight: maxMutatingInflight } } } } } },
            '#withMaxNonMutatingInflight':: d.fn(help='"MaxNonMutatingInflight is the maximum number of non-mutating requests in flight at a given time. When the server\\nexceeds this, it rejects requests."', args=[d.arg(name='maxNonMutatingInflight', type=d.T.integer)]),
            withMaxNonMutatingInflight(maxNonMutatingInflight): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { requests+: { maxNonMutatingInflight: maxNonMutatingInflight } } } } } },
          },
          '#resourcesToStoreInETCDEvents':: d.obj(help="\"ResourcesToStoreInETCDEvents contains a list of resources which should be stored in etcd-events instead of\\netcd-main. The 'events' resource is always stored in etcd-events. Note that adding or removing resources from\\nthis list will not migrate them automatically from the etcd-main to etcd-events or vice versa.\""),
          resourcesToStoreInETCDEvents: {
            '#withGroup':: d.fn(help='"Group is the API group name."', args=[d.arg(name='group', type=d.T.string)]),
            withGroup(group): { group: group },
            '#withResource':: d.fn(help='"Resource is the resource name."', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { resource: resource },
          },
          '#serviceAccountConfig':: d.obj(help='"ServiceAccountConfig contains configuration settings for the service account handling\\nof the kube-apiserver."'),
          serviceAccountConfig: {
            '#withAcceptedIssuers':: d.fn(help='"AcceptedIssuers is an additional set of issuers that are used to determine which service account tokens are accepted.\\nThese values are not used to generate new service account tokens. Only useful when service account tokens are also\\nissued by another external system or a change of the current issuer that is used for generating tokens is being performed."', args=[d.arg(name='acceptedIssuers', type=d.T.array)]),
            withAcceptedIssuers(acceptedIssuers): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { serviceAccountConfig+: { acceptedIssuers: if std.isArray(v=acceptedIssuers) then acceptedIssuers else [acceptedIssuers] } } } } } },
            '#withAcceptedIssuersMixin':: d.fn(help='"AcceptedIssuers is an additional set of issuers that are used to determine which service account tokens are accepted.\\nThese values are not used to generate new service account tokens. Only useful when service account tokens are also\\nissued by another external system or a change of the current issuer that is used for generating tokens is being performed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='acceptedIssuers', type=d.T.array)]),
            withAcceptedIssuersMixin(acceptedIssuers): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { serviceAccountConfig+: { acceptedIssuers+: if std.isArray(v=acceptedIssuers) then acceptedIssuers else [acceptedIssuers] } } } } } },
            '#withExtendTokenExpiration':: d.fn(help='"ExtendTokenExpiration turns on projected service account expiration extension during token generation, which\\nhelps safe transition from legacy token to bound service account token feature. If this flag is enabled,\\nadmission injected tokens would be extended up to 1 year to prevent unexpected failure during transition,\\nignoring value of service-account-max-token-expiration."', args=[d.arg(name='extendTokenExpiration', type=d.T.boolean)]),
            withExtendTokenExpiration(extendTokenExpiration): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { serviceAccountConfig+: { extendTokenExpiration: extendTokenExpiration } } } } } },
            '#withIssuer':: d.fn(help='"Issuer is the identifier of the service account token issuer. The issuer will assert this\\nidentifier in \\"iss\\" claim of issued tokens. This value is used to generate new service account tokens.\\nThis value is a string or URI. Defaults to URI of the API server."', args=[d.arg(name='issuer', type=d.T.string)]),
            withIssuer(issuer): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { serviceAccountConfig+: { issuer: issuer } } } } } },
            '#withMaxTokenExpiration':: d.fn(help='"MaxTokenExpiration is the maximum validity duration of a token created by the service account token issuer. If an\\notherwise valid TokenRequest with a validity duration larger than this value is requested, a token will be issued\\nwith a validity duration of this value.\\nThis field must be within [30d,90d]."', args=[d.arg(name='maxTokenExpiration', type=d.T.string)]),
            withMaxTokenExpiration(maxTokenExpiration): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { serviceAccountConfig+: { maxTokenExpiration: maxTokenExpiration } } } } } },
          },
          '#sni':: d.obj(help='"SNI contains configuration options for the TLS SNI settings."'),
          sni: {
            '#withDomainPatterns':: d.fn(help='"DomainPatterns is a list of fully qualified domain names, possibly with prefixed wildcard segments. The domain\\npatterns also allow IP addresses, but IPs should only be used if the apiserver has visibility to the IP address\\nrequested by a client. If no domain patterns are provided, the names of the certificate are extracted.\\nNon-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names."', args=[d.arg(name='domainPatterns', type=d.T.array)]),
            withDomainPatterns(domainPatterns): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { sni+: { domainPatterns: if std.isArray(v=domainPatterns) then domainPatterns else [domainPatterns] } } } } } },
            '#withDomainPatternsMixin':: d.fn(help='"DomainPatterns is a list of fully qualified domain names, possibly with prefixed wildcard segments. The domain\\npatterns also allow IP addresses, but IPs should only be used if the apiserver has visibility to the IP address\\nrequested by a client. If no domain patterns are provided, the names of the certificate are extracted.\\nNon-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='domainPatterns', type=d.T.array)]),
            withDomainPatternsMixin(domainPatterns): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { sni+: { domainPatterns+: if std.isArray(v=domainPatterns) then domainPatterns else [domainPatterns] } } } } } },
            '#withSecretName':: d.fn(help="\"SecretName is the name of a secret containing the TLS certificate and private key.\\nIf not configured, Gardener falls back to a secret labelled with 'gardener.cloud/role=garden-cert'.\"", args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { sni+: { secretName: secretName } } } } } },
          },
          '#structuredAuthentication':: d.obj(help='"StructuredAuthentication contains configuration settings for structured authentication for the kube-apiserver.\\nThis field is only available for Kubernetes v1.30 or later."'),
          structuredAuthentication: {
            '#withConfigMapName':: d.fn(help='"ConfigMapName is the name of the ConfigMap in the project namespace which contains AuthenticationConfiguration\\nfor the kube-apiserver."', args=[d.arg(name='configMapName', type=d.T.string)]),
            withConfigMapName(configMapName): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { structuredAuthentication+: { configMapName: configMapName } } } } } },
          },
          '#structuredAuthorization':: d.obj(help='"StructuredAuthorization contains configuration settings for structured authorization for the kube-apiserver.\\nThis field is only available for Kubernetes v1.30 or later."'),
          structuredAuthorization: {
            '#kubeconfigs':: d.obj(help='"Kubeconfigs is a list of references for kubeconfigs for the authorization webhooks."'),
            kubeconfigs: {
              '#withAuthorizerName':: d.fn(help='"AuthorizerName is the name of a webhook authorizer."', args=[d.arg(name='authorizerName', type=d.T.string)]),
              withAuthorizerName(authorizerName): { authorizerName: authorizerName },
              '#withSecretName':: d.fn(help='"SecretName is the name of a secret containing the kubeconfig."', args=[d.arg(name='secretName', type=d.T.string)]),
              withSecretName(secretName): { secretName: secretName },
            },
            '#withConfigMapName':: d.fn(help='"ConfigMapName is the name of the ConfigMap in the project namespace which contains AuthorizationConfiguration for\\nthe kube-apiserver."', args=[d.arg(name='configMapName', type=d.T.string)]),
            withConfigMapName(configMapName): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { structuredAuthorization+: { configMapName: configMapName } } } } } },
            '#withKubeconfigs':: d.fn(help='"Kubeconfigs is a list of references for kubeconfigs for the authorization webhooks."', args=[d.arg(name='kubeconfigs', type=d.T.array)]),
            withKubeconfigs(kubeconfigs): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { structuredAuthorization+: { kubeconfigs: if std.isArray(v=kubeconfigs) then kubeconfigs else [kubeconfigs] } } } } } },
            '#withKubeconfigsMixin':: d.fn(help='"Kubeconfigs is a list of references for kubeconfigs for the authorization webhooks."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='kubeconfigs', type=d.T.array)]),
            withKubeconfigsMixin(kubeconfigs): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { structuredAuthorization+: { kubeconfigs+: if std.isArray(v=kubeconfigs) then kubeconfigs else [kubeconfigs] } } } } } },
          },
          '#watchCacheSizes':: d.obj(help="\"WatchCacheSizes contains configuration of the API server's watch cache sizes.\\nConfiguring these flags might be useful for large-scale Shoot clusters with a lot of parallel update requests\\nand a lot of watching controllers (e.g. large ManagedSeed clusters). When the API server's watch cache's\\ncapacity is too small to cope with the amount of update requests and watchers for a particular resource, it\\nmight happen that controller watches are permanently stopped with `too old resource version` errors.\\nStarting from kubernetes v1.19, the API server's watch cache size is adapted dynamically and setting the watch\\ncache size flags will have no effect, except when setting it to 0 (which disables the watch cache).\""),
          watchCacheSizes: {
            '#resources':: d.obj(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"'),
            resources: {
              '#withApiGroup':: d.fn(help='"APIGroup is the API group of the resource for which the watch cache size should be configured.\\nAn unset value is used to specify the legacy core API (e.g. for `secrets`)."', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { apiGroup: apiGroup },
              '#withResource':: d.fn(help='"Resource is the name of the resource for which the watch cache size should be configured\\n(in lowercase plural form, e.g. `secrets`)."', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resource: resource },
              '#withSize':: d.fn(help='"CacheSize specifies the watch cache size that should be configured for the specified resource."', args=[d.arg(name='size', type=d.T.integer)]),
              withSize(size): { size: size },
            },
            '#withDefault':: d.fn(help='"Default configures the default watch cache size of the kube-apiserver\\n(flag `--default-watch-cache-size`, defaults to 100).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"', args=[d.arg(name='default', type=d.T.integer)]),
            withDefault(default): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { watchCacheSizes+: { default: default } } } } } },
            '#withResources':: d.fn(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"', args=[d.arg(name='resources', type=d.T.array)]),
            withResources(resources): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { watchCacheSizes+: { resources: if std.isArray(v=resources) then resources else [resources] } } } } } },
            '#withResourcesMixin':: d.fn(help='"Resources configures the watch cache size of the kube-apiserver per resource\\n(flag `--watch-cache-sizes`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resources', type=d.T.array)]),
            withResourcesMixin(resources): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { watchCacheSizes+: { resources+: if std.isArray(v=resources) then resources else [resources] } } } } } },
          },
          '#withAdmissionPlugins':: d.fn(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener), and, if desired, the corresponding\\nconfiguration."', args=[d.arg(name='admissionPlugins', type=d.T.array)]),
          withAdmissionPlugins(admissionPlugins): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { admissionPlugins: if std.isArray(v=admissionPlugins) then admissionPlugins else [admissionPlugins] } } } } },
          '#withAdmissionPluginsMixin':: d.fn(help='"AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener), and, if desired, the corresponding\\nconfiguration."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='admissionPlugins', type=d.T.array)]),
          withAdmissionPluginsMixin(admissionPlugins): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { admissionPlugins+: if std.isArray(v=admissionPlugins) then admissionPlugins else [admissionPlugins] } } } } },
          '#withApiAudiences':: d.fn(help='"APIAudiences are the identifiers of the API. The service account token authenticator will\\nvalidate that tokens used against the API are bound to at least one of these audiences.\\nDefaults to [\\"kubernetes\\"]."', args=[d.arg(name='apiAudiences', type=d.T.array)]),
          withApiAudiences(apiAudiences): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { apiAudiences: if std.isArray(v=apiAudiences) then apiAudiences else [apiAudiences] } } } } },
          '#withApiAudiencesMixin':: d.fn(help='"APIAudiences are the identifiers of the API. The service account token authenticator will\\nvalidate that tokens used against the API are bound to at least one of these audiences.\\nDefaults to [\\"kubernetes\\"]."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='apiAudiences', type=d.T.array)]),
          withApiAudiencesMixin(apiAudiences): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { apiAudiences+: if std.isArray(v=apiAudiences) then apiAudiences else [apiAudiences] } } } } },
          '#withDefaultNotReadyTolerationSeconds':: d.fn(help='"DefaultNotReadyTolerationSeconds indicates the tolerationSeconds of the toleration for notReady:NoExecute\\nthat is added by default to every pod that does not already have such a toleration (flag `--default-not-ready-toleration-seconds`).\\nThe field has effect only when the `DefaultTolerationSeconds` admission plugin is enabled.\\nDefaults to 300."', args=[d.arg(name='defaultNotReadyTolerationSeconds', type=d.T.integer)]),
          withDefaultNotReadyTolerationSeconds(defaultNotReadyTolerationSeconds): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { defaultNotReadyTolerationSeconds: defaultNotReadyTolerationSeconds } } } } },
          '#withDefaultUnreachableTolerationSeconds':: d.fn(help='"DefaultUnreachableTolerationSeconds indicates the tolerationSeconds of the toleration for unreachable:NoExecute\\nthat is added by default to every pod that does not already have such a toleration (flag `--default-unreachable-toleration-seconds`).\\nThe field has effect only when the `DefaultTolerationSeconds` admission plugin is enabled.\\nDefaults to 300."', args=[d.arg(name='defaultUnreachableTolerationSeconds', type=d.T.integer)]),
          withDefaultUnreachableTolerationSeconds(defaultUnreachableTolerationSeconds): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { defaultUnreachableTolerationSeconds: defaultUnreachableTolerationSeconds } } } } },
          '#withEnableAnonymousAuthentication':: d.fn(help='"EnableAnonymousAuthentication defines whether anonymous requests to the secure port\\nof the API server should be allowed (flag `--anonymous-auth`).\\nSee: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/\\n\\nDeprecated: This field is deprecated and will be removed in a future release.\\nPlease use anonymous authentication configuration instead.\\nFor more information see: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#anonymous-authenticator-configuration"', args=[d.arg(name='enableAnonymousAuthentication', type=d.T.boolean)]),
          withEnableAnonymousAuthentication(enableAnonymousAuthentication): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { enableAnonymousAuthentication: enableAnonymousAuthentication } } } } },
          '#withEventTTL':: d.fn(help='"EventTTL controls the amount of time to retain events.\\nDefaults to 1h."', args=[d.arg(name='eventTTL', type=d.T.string)]),
          withEventTTL(eventTTL): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { eventTTL: eventTTL } } } } },
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { featureGates+: featureGates } } } } },
          '#withResourcesToStoreInETCDEvents':: d.fn(help="\"ResourcesToStoreInETCDEvents contains a list of resources which should be stored in etcd-events instead of\\netcd-main. The 'events' resource is always stored in etcd-events. Note that adding or removing resources from\\nthis list will not migrate them automatically from the etcd-main to etcd-events or vice versa.\"", args=[d.arg(name='resourcesToStoreInETCDEvents', type=d.T.array)]),
          withResourcesToStoreInETCDEvents(resourcesToStoreInETCDEvents): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { resourcesToStoreInETCDEvents: if std.isArray(v=resourcesToStoreInETCDEvents) then resourcesToStoreInETCDEvents else [resourcesToStoreInETCDEvents] } } } } },
          '#withResourcesToStoreInETCDEventsMixin':: d.fn(help="\"ResourcesToStoreInETCDEvents contains a list of resources which should be stored in etcd-events instead of\\netcd-main. The 'events' resource is always stored in etcd-events. Note that adding or removing resources from\\nthis list will not migrate them automatically from the etcd-main to etcd-events or vice versa.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='resourcesToStoreInETCDEvents', type=d.T.array)]),
          withResourcesToStoreInETCDEventsMixin(resourcesToStoreInETCDEvents): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { resourcesToStoreInETCDEvents+: if std.isArray(v=resourcesToStoreInETCDEvents) then resourcesToStoreInETCDEvents else [resourcesToStoreInETCDEvents] } } } } },
          '#withRuntimeConfig':: d.fn(help='"RuntimeConfig contains information about enabled or disabled APIs."', args=[d.arg(name='runtimeConfig', type=d.T.object)]),
          withRuntimeConfig(runtimeConfig): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { runtimeConfig: runtimeConfig } } } } },
          '#withRuntimeConfigMixin':: d.fn(help='"RuntimeConfig contains information about enabled or disabled APIs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='runtimeConfig', type=d.T.object)]),
          withRuntimeConfigMixin(runtimeConfig): { spec+: { virtualCluster+: { kubernetes+: { kubeAPIServer+: { runtimeConfig+: runtimeConfig } } } } },
        },
        '#kubeControllerManager':: d.obj(help='"KubeControllerManager contains configuration settings for the kube-controller-manager."'),
        kubeControllerManager: {
          '#horizontalPodAutoscaler':: d.obj(help='"HorizontalPodAutoscalerConfig contains horizontal pod autoscaler configuration settings for the kube-controller-manager."'),
          horizontalPodAutoscaler: {
            '#withCpuInitializationPeriod':: d.fn(help='"The period after which a ready pod transition is considered to be the first."', args=[d.arg(name='cpuInitializationPeriod', type=d.T.string)]),
            withCpuInitializationPeriod(cpuInitializationPeriod): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { horizontalPodAutoscaler+: { cpuInitializationPeriod: cpuInitializationPeriod } } } } } },
            '#withDownscaleStabilization':: d.fn(help='"The configurable window at which the controller will choose the highest recommendation for autoscaling."', args=[d.arg(name='downscaleStabilization', type=d.T.string)]),
            withDownscaleStabilization(downscaleStabilization): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { horizontalPodAutoscaler+: { downscaleStabilization: downscaleStabilization } } } } } },
            '#withInitialReadinessDelay':: d.fn(help='"The configurable period at which the horizontal pod autoscaler considers a Pod not yet ready given that its unready and it has  transitioned to unready during that time."', args=[d.arg(name='initialReadinessDelay', type=d.T.string)]),
            withInitialReadinessDelay(initialReadinessDelay): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { horizontalPodAutoscaler+: { initialReadinessDelay: initialReadinessDelay } } } } } },
            '#withSyncPeriod':: d.fn(help='"The period for syncing the number of pods in horizontal pod autoscaler."', args=[d.arg(name='syncPeriod', type=d.T.string)]),
            withSyncPeriod(syncPeriod): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { horizontalPodAutoscaler+: { syncPeriod: syncPeriod } } } } } },
            '#withTolerance':: d.fn(help='"The minimum change (from 1.0) in the desired-to-actual metrics ratio for the horizontal pod autoscaler to consider scaling."', args=[d.arg(name='tolerance', type=d.T.number)]),
            withTolerance(tolerance): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { horizontalPodAutoscaler+: { tolerance: tolerance } } } } } },
          },
          '#withCertificateSigningDuration':: d.fn(help='"CertificateSigningDuration is the maximum length of duration signed certificates will be given. Individual CSRs\\nmay request shorter certs by setting `spec.expirationSeconds`."', args=[d.arg(name='certificateSigningDuration', type=d.T.string)]),
          withCertificateSigningDuration(certificateSigningDuration): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { certificateSigningDuration: certificateSigningDuration } } } } },
          '#withFeatureGates':: d.fn(help='"FeatureGates contains information about enabled feature gates."', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGates(featureGates): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { featureGates: featureGates } } } } },
          '#withFeatureGatesMixin':: d.fn(help='"FeatureGates contains information about enabled feature gates."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='featureGates', type=d.T.object)]),
          withFeatureGatesMixin(featureGates): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { featureGates+: featureGates } } } } },
          '#withNodeCIDRMaskSize':: d.fn(help='"NodeCIDRMaskSize defines the mask size for node cidr in cluster (default is 24). This field is immutable."', args=[d.arg(name='nodeCIDRMaskSize', type=d.T.integer)]),
          withNodeCIDRMaskSize(nodeCIDRMaskSize): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { nodeCIDRMaskSize: nodeCIDRMaskSize } } } } },
          '#withNodeMonitorGracePeriod':: d.fn(help='"NodeMonitorGracePeriod defines the grace period before an unresponsive node is marked unhealthy."', args=[d.arg(name='nodeMonitorGracePeriod', type=d.T.string)]),
          withNodeMonitorGracePeriod(nodeMonitorGracePeriod): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { nodeMonitorGracePeriod: nodeMonitorGracePeriod } } } } },
          '#withPodEvictionTimeout':: d.fn(help='"PodEvictionTimeout defines the grace period for deleting pods on failed nodes. Defaults to 2m.\\n\\nDeprecated: The corresponding kube-controller-manager flag `--pod-eviction-timeout` is deprecated\\nin favor of the kube-apiserver flags `--default-not-ready-toleration-seconds` and `--default-unreachable-toleration-seconds`.\\nThe `--pod-eviction-timeout` flag does not have effect when the taint based eviction is enabled. The taint\\nbased eviction is beta (enabled by default) since Kubernetes 1.13 and GA since Kubernetes 1.18. Hence,\\ninstead of setting this field, set the `spec.kubernetes.kubeAPIServer.defaultNotReadyTolerationSeconds` and\\n`spec.kubernetes.kubeAPIServer.defaultUnreachableTolerationSeconds`. Setting this field is forbidden starting\\nfrom Kubernetes 1.33."', args=[d.arg(name='podEvictionTimeout', type=d.T.string)]),
          withPodEvictionTimeout(podEvictionTimeout): { spec+: { virtualCluster+: { kubernetes+: { kubeControllerManager+: { podEvictionTimeout: podEvictionTimeout } } } } },
        },
        '#withVersion':: d.fn(help='"Version is the semantic Kubernetes version to use for the virtual garden cluster."', args=[d.arg(name='version', type=d.T.string)]),
        withVersion(version): { spec+: { virtualCluster+: { kubernetes+: { version: version } } } },
      },
      '#maintenance':: d.obj(help='"Maintenance contains information about the time window for maintenance operations."'),
      maintenance: {
        '#timeWindow':: d.obj(help='"TimeWindow contains information about the time window for maintenance operations."'),
        timeWindow: {
          '#withBegin':: d.fn(help='"Begin is the beginning of the time window in the format HHMMSS+ZONE, e.g. \\"220000+0100\\".\\nIf not present, a random value will be computed."', args=[d.arg(name='begin', type=d.T.string)]),
          withBegin(begin): { spec+: { virtualCluster+: { maintenance+: { timeWindow+: { begin: begin } } } } },
          '#withEnd':: d.fn(help='"End is the end of the time window in the format HHMMSS+ZONE, e.g. \\"220000+0100\\".\\nIf not present, the value will be computed based on the \\"Begin\\" value."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { spec+: { virtualCluster+: { maintenance+: { timeWindow+: { end: end } } } } },
        },
      },
      '#networking':: d.obj(help='"Networking contains information about cluster networking such as CIDRs, etc."'),
      networking: {
        '#withServices':: d.fn(help='"Services are the CIDRs of the service network. Elements can be appended to this list, but not removed."', args=[d.arg(name='services', type=d.T.array)]),
        withServices(services): { spec+: { virtualCluster+: { networking+: { services: if std.isArray(v=services) then services else [services] } } } },
        '#withServicesMixin':: d.fn(help='"Services are the CIDRs of the service network. Elements can be appended to this list, but not removed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.array)]),
        withServicesMixin(services): { spec+: { virtualCluster+: { networking+: { services+: if std.isArray(v=services) then services else [services] } } } },
      },
    },
    '#withExtensions':: d.fn(help='"Extensions contain type and provider information for Garden extensions."', args=[d.arg(name='extensions', type=d.T.array)]),
    withExtensions(extensions): { spec+: { extensions: if std.isArray(v=extensions) then extensions else [extensions] } },
    '#withExtensionsMixin':: d.fn(help='"Extensions contain type and provider information for Garden extensions."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='extensions', type=d.T.array)]),
    withExtensionsMixin(extensions): { spec+: { extensions+: if std.isArray(v=extensions) then extensions else [extensions] } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
